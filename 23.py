from functools import cache
import time

from sys import setrecursionlimit

# Меняем глубину рекурсии
setrecursionlimit(5000000)


# Декоратор cache значительно ускоряет функцию позволяя ей не выполнять вычисления которые она уже выполняла
def test_without(x, y):
    if x == y:
        return 1
    if x > y:
        return 0
    return test_without(x + 1, y) + test_without(x * 3, y)


@cache
def test_with(x, y):
    if x == y:
        return 1
    if x > y:
        return 0
    return test_with(x + 1, y) + test_with(x * 3, y)


# Можно запустить этот код чтобы убедиться в работоспособности cache
# t = time.time()
# print(test_without(1, 450))
# print(f"Without cache: {time.time() - t}")
# t1 = time.time()
# print(test_with(1, 450))
# print(f'With cache: {time.time() - t1}')

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#                                                                       ЗАДАЧИ
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Сколько вариантов от 4 до 34
@cache
def f_t(x, y):
    if x == y:
        return 1
    if x > y:
        return 0
    return f_t(x + 1, y) + f_t(x * 3, y)


# print(f_t(4, 34))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@cache
# Сколько вариантов от 3 до 16 проходящих через 12
def f_t_w(x, y):
    if x > y:
        return 0
    if x == y:
        return 1
    else:
        return f_t_w(x + 1, y) + f_t_w(x * 2, y) + f_t_w(x + 3, y)


# print(f_t_w(3, 12) * f_t_w(12, 16))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Сколько вариантов от 2 до 12 проходящих через 8 и 10

@cache
def f(x, y):
    if x > y:
        return 0
    if x == y:
        return 1
    else:
        return f(x + 1, y) + f(x + 2, y) + f(x * 3, y)


# print(f(2, 8) * f(8, 10) * f(10, 12))
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Сколько вариантов 3 в 16 не проходящих через 6 или 12
@cache
def f_n(x, y):
    if x > y or x == 6 or x == 12:
        return 0
    if x == y:
        return 1
    else:
        return f_n(x + 1, y) + f_n(x * 2, y) + f_n(x + 3, y)


# print(f(3, 16))
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Сколько 3 в 20, проходящих через 9 и не содержащих числа 15
@cache
def f(x, y):
    if x > y or x == 15:
        return 0
    if x == y:
        return 1
    else:
        return f(x + 1, y) + f(x + 2, y)

# print(f(3, 9) * f(9, 20))
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
